
// *********** 6. Як перевірити 2 об'єкта на ідентичність?
// напиши або використай з бібліотеки функцію deeoEqual яка буде проходити циклом по ключах двох об'єктів і перевірятиме значенняцих ключів. Функція має працювати рекурсивно

function deepEqual(obj1, obj2) {
  // Перевірка на рівність типів та на наявність об'єктів
  if (obj1 === obj2) {
    return true;
  }

  // Перевірка на null
  if (obj1 === null || obj2 === null) {
    return false;
  }

  // Перевірка на тип об'єктів
  if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
    return false;
  }

  // Отримання ключів об'єктів
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  // Перевірка на рівність кількості ключів
  if (keys1.length !== keys2.length) {
    return false;
  }

  // Перевірка на рівність значень для кожного ключа
  for (let key of keys1) {
    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }
// for (let key of keys1) {: Цикл for...of використовується для ітерації через ключі (властивості) об'єкта obj1.

// if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {: Умова перевіряє дві речі:

// !keys2.includes(key): Перевіряє, чи ключ key з об'єкта obj1 міститься в ключах об'єкта obj2. Якщо ні, це означає, що об'єкти мають різні ключі, тобто вони не рівні.
// !deepEqual(obj1[key], obj2[key]): Викликає рекурсивно функцію deepEqual для порівняння значень, що відповідають ключу key у двох об'єктах (obj1 та obj2). Якщо значення не рівні, то функція повертає false, означаючи, що об'єкти не рівні.
// Якщо будь-яка з умов у виразі if стає true, то вся функція deepEqual повертає false, означаючи, що об'єкти не рівні.

// Цей код використовується для порівняння ключів і значень об'єктів obj1 і obj2 у циклі. Якщо будь-який з них виявляється різним, функція повертає false. Якщо ж жодна умова не виконується, це означає, що всі ключі та значення однакові, і функція продовжує виконання.
    
    
    

  // Якщо всі перевірки пройдені, об'єкти рівні
  return true;
}

// Приклад використання
const objA = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 3
    }
  }
};

const objB = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 3
    }
  }
};

const objC = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 4  // Змінено значення для тесту різниці
    }
  }
};

console.log(deepEqual(objA, objB)); // Виведе true
console.log(deepEqual(objA, objC)); // Виведе false


// порівняти за допомогою JSON.sringify

function deepEqualWithJSON(obj1, obj2) {
  const str1 = JSON.stringify(obj1);
  const str2 = JSON.stringify(obj2);
  return str1 === str2;
}



console.log(deepEqualWithJSON(objA, objB)); // Виведе true
console.log(deepEqualWithJSON(objA, objC)); // Виведе false

// функції в об'єктах будуть втрачені, оскільки функції не можна серіалізувати в JSON.
// Порівнювані об'єкти повинні мати однаковий порядок ключів, інакше порівняння може бути неточним.
// Властивості, які мають значення undefined, можуть бути втрачені при серіалізації.


// *********** 7. Як зробити копію об'єкта? 

// Щоб створити поверхневу копію об'єкта в JavaScript, ви можете використовувати кілька підходів. Ось декілька способів:

// Використання Spread-оператора (поверхнева копія):


const originalObject1 = { a: 1, b: { c: 2 } };
const copyObject1 = { ...originalObject1 };
// Цей метод створює новий об'єкт та копіює всі його властивості.

// Використання Object.assign (поверхнева копія):


const originalObject2 = { a: 1, b: { c: 2 } };
const copyObject2 = Object.assign({}, originalObject2);
console.log(copyObject2);

console.log(deepEqual(originalObject1, copyObject1));
// Цей метод також створює новий об'єкт та копіює всі властивості.

// Використання методу slice (тільки для масивів):


const originalArray = [1, 2, 3];
const copyArray = originalArray.slice();
// Цей метод призначений для масивів і створює новий масив, включаючи всі елементи оригінального масиву.

// Використання Object.create (зберігає прототип):


const originalObject = { a: 1, b: { c: 2 } };
const copyObject = Object.create(Object.getPrototypeOf(originalObject));
Object.assign(copyObject, originalObject);
// Цей метод створює новий об'єкт, який має той самий прототип, що і оригінальний об'єкт, і копіює його властивості.

// Обов'язково поміняйте код відповідно до вашого випадку використання та вимог. Важливо враховувати, що ці методи створюють поверхневі копії, тобто вони копіюють тільки першорядні властивості,
// а не вкладені об'єкти чи масиви. Якщо ваш об'єкт має вкладені структури даних, для них може бути потрібна глибока копія.



function deepCopy(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj; // Повертаємо примітиви та null без змін
  }

  if (Array.isArray(obj)) {
    // Глибока копія для масиву
    return obj.map(element => deepCopy(element));
  }

  // Глибока копія для об'єкту
  const copiedObject = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copiedObject[key] = deepCopy(obj[key]);
    }
  }

  return copiedObject;
}

// Приклад використання
const originalObjectDeep = {
  a: 1,
  b: {
    c: 2,
    d: [3, 4]
  }
};

const copiedObject = deepCopy(originalObjectDeep);

console.log(originalObjectDeep); // Початковий об'єкт
console.log(copiedObject);   // Глибока копія


// function deepCopy(obj) {: Ця стрічка визначає функцію deepCopy, яка буде використовуватися для створення глибоких копій об'єктів.

// if (obj === null || typeof obj !== 'object') { return obj; }: Це перевірка базового випадку для рекурсії. Якщо obj є примітивом або null, то функція просто повертає obj, оскільки немає необхідності копіювати примітиви або null.

// if (Array.isArray(obj)) { return obj.map(element => deepCopy(element)); }: Якщо obj є масивом, використовується метод map, щоб застосувати deepCopy для кожного елемента масиву. Це забезпечує глибоку копію масиву.

// const copiedObject = {};: Створюється порожній об'єкт copiedObject, який буде використовуватися для копіювання властивостей об'єкту.

// for (let key in obj) { if (obj.hasOwnProperty(key)) { copiedObject[key] = deepCopy(obj[key]); } }: Цикл for...in проходить через всі властивості об'єкту obj. Умова obj.hasOwnProperty(key) гарантує, що ми копіюємо тільки власні властивості об'єкта (а не ті, які можуть бути у прототипі). Для кожної властивості застосовується рекурсивно deepCopy, щоб забезпечити глибоку копію.

// return copiedObject;: Повертається новий об'єкт copiedObject – глибока копія вхідного об'єкта.

// Ця функція глибокої копії рекурсивно обробляє об'єкти та масиви, забезпечуючи глибоке копіювання всіх вкладених структур даних

    
  // *********** 10.  Методи роботи р масивом
// avaScript надає ряд вбудованих методів для роботи з масивами. Ось деякі з найбільш часто використовуваних:

// push(): Додає один чи більше елементів до кінця масиву і повертає нову довжину масиву.


const arr = [1, 2, 3];
arr.push(4, 5);
    // Тепер arr = [1, 2, 3, 4, 5]


    
// pop(): Видаляє останній елемент з масиву і повертає його значення.


const arr1 = [1, 2, 3];
const lastElement = arr1.pop();
    // Тепер arr = [1, 2], lastElement = 3
    

// shift(): Видаляє перший елемент з масиву і повертає його значення.


const arr2 = [1, 2, 3];
const firstElement = arr2.shift();
    // Тепер arr = [2, 3], firstElement = 1
    

// unshift(): Додає один чи більше елементів на початок масиву і повертає нову довжину масиву.


const arr3 = [2, 3];
arr3.unshift(0, 1);
    // Тепер arr = [0, 1, 2, 3]
    

// splice(): Змінює вміст масиву, додаючи/видаляючи елементи.


const arr4 = [1, 2, 3, 4, 5];
arr4.splice(2, 1, 'a', 'b');
    // Тепер arr = [1, 2, 'a', 'b', 4, 5]
    

// concat(): Об'єднує два або більше масивів.


const arr5 = [1, 2, 3];
const arr6 = [4, 5];
const newArr = arr1.concat(arr2);
    // newArr = [1, 2, 3, 4, 5]
    

// slice(): Повертає вибраний фрагмент масиву без зміни вихідного масиву.


const arr7 = [1, 2, 3, 4, 5];
const slicedArr = arr.slice(1, 4);
// slicedArr = [2, 3, 4]


// *********** 16. Що таке область втдимості?

// Локальна область видимості (Local Scope):

// Змінні та функції, оголошені всередині функції чи блоку коду, належать до локальної області видимості.
// Вони доступні тільки всередині тієї функції чи блоку коду, де вони були оголошені.

function localFunction() {
const localVariable = "I'm local!";
  console.log(localVariable);
}

localFunction(); // "I'm local!"
// console.log(localVariable); // ReferenceError: localVariable is not defined

// Лексична область видимості (Lexical Scope):

// Область видимості визначається структурою програми (лексичним контекстом), а не об'єктом виклику чи поточним контекстом виклику.
// Дозволяє функціям отримувати доступ до змінних зі свого власного об'єму видимості, а також до змінних в області видимості, в якій вони були оголошені.

function outerFunction() {
  var outerVariable = "I'm outer!";

  function innerFunction() {
    console.log(outerVariable);
  }

  innerFunction(); // "I'm outer!"
}

outerFunction();


// *********** 17. Чим Function Declaration та Function Expression відрізняються? 

// Function Declaration та Function Expression - це два основних способи оголошення функцій в JavaScript.Основні відмінності між ними полягають 
// у тому, як вони оголошуються та коли їх можна викликати.

// Function Declaration:
// Спосіб оголошення:

// Використовується ключове слово function, а після нього вказується ім'я функції.

// function myFunction() {
//   // тіло функції
// }
// Підняття (Hoisting):

// Функції, оголошені за допомогою Function Declaration, піднімаються вгору у коді. Тобто їх можна викликати до їхнього фактичного оголошення у коді.

// myFunction(); // працює навіть перед оголошенням

// function myFunction() {
//   console.log('Hello, World!');
// }



// Function Expression:
// Спосіб оголошення:

// Функцію присвоюють змінній, а сама функція може бути анонімною (без імені) або мати ім'я.

// const myFunction = function() {
//   // тіло функції
// };

// // або анонімна функція

// const myFunction = function() {
//   // тіло функції
// };


// Підняття (Hoisting):

// Лише сама змінна, до якої призначено функцію, піднімається, але не сама функція. Тому її можна викликати тільки після того, як вона була призначена.

// Помилка: myFunction is not a function
// myFunction();

// const myFunction = function() {
//   console.log('Hello, World!');
// };

// Вибір між Function Declaration та Function Expression:
// Підняття:

// Function Declaration можна викликати до оголошення у коді, завдяки підняттю.
// Function Expression потрібно оголошувати перед викликом, інакше виникає помилка.
// Ім'я:

// Function Declaration обов'язково має ім'я функції.
// Function Expression може бути анонімною (без імені), але також може мати ім'я.
// Застосування:

// Function Declaration зручно використовувати для оголошення функцій на рівні блоку або глобально.
// Function Expression використовується, коли функція потрібна для виразу чи коли необхідно призначити функцію змінній.

// Function Declaration
function sum1(a, b) {
  return a + b;
}

// Function Expression
const sum2 = function(a, b) {
  return a + b;
};

// Або анонімна Function Expression
const sum3 = function(a, b) {
  return a + b;
};

// Ім'я анонімної Function Expression може бути використане всередині самої функції (для рекурсії або виклику самої себе).
const factorial = function calcFactorial(n) {
  if (n <= 1) {
    return 1;
  }
  return n * calcFactorial(n - 1);
};


// *********** 19. чи існує аналог arguments для стрілочної функції ?


// В стрілочних функціях відсутній об'єкт arguments, який доступний в звичайних функціях. Замість цього стрілочні функції мають доступ до змінної arguments контексту, в якому вони були створені.

// Проте, важливо відзначити, що змінна arguments в стрілочних функціях має інший зміст. Вона представляє аргументи зовнішньої функції, а не аргументи самої стрілочної функції.

// Ось приклад:


function regularFunction() {
  const arrowFunction = () => {
    console.log(arguments); // arguments тут відноситься до аргументів regularFunction, а не стрілочної функції
  };

    arrowFunction(1, 2, 3);
  
}

regularFunction(4, 5, 6);


// У цьому прикладі arguments в стрілочній функції вказує на аргументи зовнішньої функції regularFunction, а не на аргументи стрілочної функції.


// Якщо потрібно мати доступ до аргументів самої стрілочної функції, вам слід використовувати рест - параметр:


const arrowFunction = (...args) => {
  console.log(args); // Аргументи самої стрілочної функції
};

arrowFunction(1, 2, 3);


// Використання рест-параметра (...args) дозволяє отримати доступ до всіх аргументів стрілочної функції.

// *********** 22. Що таке замикання (Closures)? 
// У JavaScript термін "замикання"(closures) вказує на те, коли функція має доступ до змінних з області видимості,
//   в якій вона була створена, навіть після того, як ця область видимості припинила свою роботу.
//   Замикання дозволяють функціям "зберігати" стан та отримувати доступ до нього в майбутньому.

// Ось приклад замикання в JavaScript:


function outerFunction1() {
  let outerVariable = "Зовнішня змінна";

  function innerFunction() {
    console.log(outerVariable);
  }

  return innerFunction;
}

// Створюємо замикання
let closure = outerFunction1();

// Викликаємо функцію, яка має доступ до зовнішньої змінної
closure(); // Виведе: Зовнішня змінна


// У цьому прикладі innerFunction є внутрішньою функцією, яка має доступ до outerVariable, яка знаходиться в області видимості outerFunction.
// Коли ми викликаємо outerFunction, вона повертає innerFunction, і ми зберігаємо її в змінній closure.Після цього, коли ми викликаємо closure(),
//   вона все ще має доступ до outerVariable, навіть якщо outerFunction завершила свою роботу.


// *********** 23. для чого використовують замикання ? 
  
// Замикання використовуються в JavaScript для створення приватних змінних, реалізації функцій з збереженням стану та інших сценаріїв,
//   де потрібно утримувати доступ до змінних після завершення роботи функції.


// Інкапсуляція:
// Інкапсуляція в ООП вказує на обгортання даних та методів, які працюють з цими даними, в один об'єкт.
// Об'єкт зберігає свої дані в приватному стані та надає обмежений доступ до цих даних через публічні методи (гетери та сетери).
// Інші об'єкти не повинні масово звертатися до внутрішньої структури даних; замість цього, вони взаємодіють лише через визначені інтерфейси.



class BankAccount {
  #balance = 0; // приватна властивість

  constructor(initialBalance) {
    this.#balance = initialBalance;
  }

  getBalance() {
    return this.#balance; // гетер
  }

  deposit(amount) {
    this.#balance += amount;
  }

  withdraw(amount) {
    if (amount <= this.#balance) {
      this.#balance -= amount;
    } else {
      console.log("Недостатньо коштів");
    }
  }
}

const account = new BankAccount(1000);
console.log(account.getBalance()); // 1000
account.deposit(500);
console.log(account.getBalance()); // 1500
account.withdraw(200);
console.log(account.getBalance()); // 1300


// Карування (Encapsulation):
// Карування в ООП вказує на об'єднання пов'язаних методів та даних в одному об'єкті.
// Основна ідея - групувати схожі частини коду разом для зручності управління та підтримки.
// Об'єкти інкапсулюють свої деталі та забезпечують простий та зрозумілий інтерфейс для взаємодії з іншими частинами програми.
// Приклад на мові JavaScript:


class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this.speed = 0;
  }

  accelerate() {
    this.speed += 10;
    console.log(`${this.make} ${this.model} is accelerating. Current speed: ${this.speed} km/h`);
  }

  brake() {
    this.speed -= 5;
    console.log(`${this.make} ${this.model} is braking. Current speed: ${this.speed} km/h`);
  }
}

const myCar = new Car("Toyota", "Camry");
myCar.accelerate(); // Toyota Camry is accelerating. Current speed: 10 km/h
myCar.brake();      // Toyota Camry is braking. Current speed: 5 km/h


// В цьому прикладі, клас Car інкапсулює характеристики та поведінку автомобіля, забезпечуючи простий спосіб взаємодії з іншим кодом.

// ***********24. Що таке IFFI ?

// IFFI (Immediately Invoked Function Expression) - це вираз функції, який визивається негайно після його створення. IIFE є конструкцією в JavaScript, 
// яка оточує функцію в парних круглих дужках() та викликає її негайно.Така конструкція дозволяє уникнути забруднення глобального простору імен та 
// зберігає змінні в локальному області видимості.

// Синтаксис IIFE виглядає наступним чином:


(function() {
  // код функції тут
})();

// або з передачею аргументів:


(function(x, y) {
  // код функції тут
})(10, 20);

// Основна ідея використання IIFE полягає в тому, щоб уникнути конфліктів імен та утримати змінні в локальних областях видимості.
// Також це дозволяє виконати код негайно після його оголошення.

// Приклад використання IIFE:



(function() {
  var message = "Hello, IIFE!";
  console.log(message);
})();

// Змінна message не доступна в глобальному просторі імен
// console.log(message); // Помилка: message is not defined
// У цьому прикладі, змінна message доступна тільки всередині IIFE, і вона не забруднює глобальний простір імен.


// *********** 26. Як можна підмінити контекст виклику функції? 

// У JavaScript ви можете змінювати контекст виклику функції за допомогою методів call, apply або bind.
// Ці методи дозволяють вам явно вказати об'єкт, який буде використовуватися як this всередині функції. Ось короткий огляд кожного з цих методів:

// call метод:
// call дозволяє викликати функцію і передавати аргументи окремо.
  
// Синтаксис: function.call(thisArg, arg1, arg2, ...)


const person = {
  name: 'John'
};

function sayHello() {
  console.log(`Hello, ${this.name}!`);
}



sayHello.call(person); // Виведе: Hello, John!



// apply метод:
// apply схожий на call, але дозволяє передавати аргументи у вигляді масиву.
// Синтаксис: function.apply(thisArg, [arg1, arg2, ...])

function sayHello1(greeting) {
  console.log(`${greeting}, ${this.name}!`);
}



sayHello1.apply(person, ['Hi']); // Виведе: Hi, John!


// bind метод:
// bind повертає нову функцію, яка має заданий контекст, але не викликає її негайно.
// Синтаксис: function.bind(thisArg)



function sayHello2() {
  console.log(`Hello, ${this.name}!`);
}



const sayHelloToJohn = sayHello2.bind(person);
sayHelloToJohn(); // Виведе: Hello, John!


// Ці методи дозволяють змінювати контекст виклику функції, що є корисним при роботі з об'єктами чи при визначенні функцій в контексті
// конкретних об'єктів.

// *********** #29 Що таке прототип об'єкта?

// Прототип об'єкта - це об'єкт, який використовується для збереження властивостей та методів, які можуть бути спільно використані між багатьма об'єктами в JavaScript. 
// Кожен об'єкт в JavaScript має прототип, і він може успадковувати властивості та методи з цього прототипу.

// У JavaScript існує концепція ланцюга прототипів(prototype chain), що дозволяє об'єктам успадковувати властивості один від одного. 
// Кожен об'єкт може мати посилання на свій прототип, і цей прототип може також мати свій власний прототип, утворюючи ланцюг прототипів.

// Основний спосіб встановлення прототипу для об'єкта визначається конструктором, який створив цей об'єкт. 
// Кожен конструктор має властивість prototype, яка є об'єктом, який визначає прототип для об'єктів, створених цим конструктором.

// Приклад:


// Конструктор об'єкта Person
function Person(name) {
  this.name = name;
}

// Додавання методу до прототипу Person
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

// Створення об'єкта person за допомогою конструктора Person
const person1 = new Person('John');

// Виклик методу, успадкованого від прототипу
person1.sayHello(); // Виведе: Hello, my name is John
console.log(person1);

// У цьому прикладі Person.prototype є прототипом, який має метод sayHello.
//   Об'єкт person, створений за допомогою конструктора Person, успадковує метод sayHello через ланцюг прототипів.

// Цей механізм дозволяє ефективно ділити властивості та методи між об'єктами та використовувати поліморфізм у JavaScript.


// *********** 31  як створити об'єкт у якому не буде прототипу?

// У JavaScript кожен об'єкт має прототип. Проте, ви можете створити об'єкт без явного прототипу,
//   використовуючи Object.create(null).Це створить об'єкт, який не успадковує властивості або методи з прототипу:


const objWithoutPrototype = Object.create(null);

console.log(objWithoutPrototype.toString); // undefined
console.log(objWithoutPrototype.hasOwnProperty); // undefined

// Вищевказаний підхід використовує Object.create для створення об'єкта та передає null як аргумент.
// Такий об'єкт не буде мати властивостей або методів, успадкованих з прототипу, і буде "чистим" об'єктом без додаткових властивостей.

// Варто відзначити, що цей підхід може призвести до обмежень, оскільки об'єкт не матиме корисних методів,
// які можуть бути корисними у роботі з об'єктами в звичайних умовах. У більшості випадків використовувати о
// б'єкти з прототипом - це корисний інструмент для діління властивостей та методів між об'єктами.

// ***********32. як перевірити чи є властивість об'єкта особистою властивістю або це властивість прототипу?


// В JavaScript ви можете використовувати методи, такі як hasOwnProperty та оператор in, щоб перевірити,
//   чи є властивість об'єкта особистою (прямою) властивістю об'єкта, чи це властивість прототипу.
  
//   Ось як це можна зробити:

// Метод hasOwnProperty:
// hasOwnProperty є методом об'єкта, який перевіряє, чи є вказана властивість прямою властивістю об'єкта, і повертає true, якщо так, або false, якщо ні.


const obj = {
  prop1: 'value1'
};

console.log(obj.hasOwnProperty('prop1')); // true
console.log(obj.hasOwnProperty('toString')); // false (toString - це властивість прототипу)


// Оператор in:
// Оператор in перевіряє наявність властивості у об'єкті, включаючи властивості прототипу.



console.log('prop1' in obj); // true
console.log('toString' in obj); // true (toString - це властивість прототипу)

// Обидва методи можуть бути використані для визначення наявності конкретної властивості та
// для відокремлення власних властивостей від властивостей прототипу.
// Завдяки цим методам ви можете керувати доступом до властивостей
// та уникати непередбачених результатів при роботі з об'єктами та їх прототипами.


//  *********** 33. Як заборонити змінювати об'єкт?


// У JavaScript ви можете використовувати методи Object.freeze, Object.seal або Object.preventExtensions
// для заборони змінювати об'єкт. Кожен з цих методів використовується для роботи з властивостями об'єкта та
// забезпечення його незмінності або обмеження можливостей зміни.Розглянемо кожен метод окремо:

// Object.freeze:
// Object.freeze забороняє будь-які зміни властивостей об'єкта, включаючи додавання, видалення та зміну властивостей.
// Об'єкт стає "замороженим", і ви не зможете змінювати його структуру.


// const obj1 = {
//   prop1: 'value1'
// };

// Object.freeze(obj1);

// // Наступні операції не будуть успішними
// obj.prop1 = 'new value';
// delete obj1.prop1;
// obj.prop2 = 'value2';

// // Object.seal:
// // Object.seal забороняє додавання та видалення властивостей об'єкта, але дозволяє змінювати існуючі властивості.




// Object.seal(obj1);

// // Наступні операції не будуть успішними
// delete obj.prop1;
// obj.prop2 = 'value2';

// // Але можна змінити існуючі властивості
// obj.prop1 = 'new value';


// // Object.preventExtensions:
// // Object.preventExtensions забороняє додавання нових властивостей, але дозволяє змінювати та видаляти існуючі властивості.



// Object.preventExtensions(obj1);

// // Наступні операції не будуть успішними
// obj1.prop2 = 'value2';

// // Але можна змінювати та видаляти існуючі властивості
// obj1.prop1 = 'new value';
// delete obj1.prop1;
// // Обирайте метод, який найбільше відповідає вашим потребам в області незмінності об'єкта, залежно від того,
// // чи хочете ви заборонити будь - які зміни(заморозка), чи дозволити зміну існуючих властивостей(уплотнення або обмеження додавання та видалення).


// *****************************34. що таке дескриптори властивостей об'єкта?

// В JavaScript дескриптори властивостей об'єкта - це об'єкти, які описують характеристики властивостей об'єктів. 
// Кожна властивість об'єкта має свій власний дескриптор, який визначає, як ця властивість поводиться та як її можна змінювати.

// Дескриптор властивості може містити наступні поля:

// value: Значення властивості.
// writable: Логічне значення, яке вказує, чи можна змінювати значення властивості. За замовчуванням true.
// enumerable: Логічне значення, яке вказує, чи буде властивість видимою при ітерації через цикли. За замовчуванням true.
// configurable: Логічне значення, яке вказує, чи можна змінювати конфігурацію властивості (наприклад, видаляти властивість або змінювати дескриптор). За замовчуванням true.
// Ось приклад використання дескрипторів властивостей:


const obj3 = {
  prop: 42
};

// Отримання дескриптора властивості
const descriptor = Object.getOwnPropertyDescriptor(obj3, 'prop');

console.log(descriptor);
// { value: 42, writable: true, enumerable: true, configurable: true }


// Ви також можете встановлювати дескриптори властивостей за допомогою методу Object.defineProperty:


const obj4 = {};

Object.defineProperty(obj4, 'prop', {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: false
});

console.log(obj4.prop); // 42

// Спроба змінити значення буде неуспішною через writable: false
obj.prop = 100;

console.log(obj.prop); // 42 (не змінилося)

// Спроба видалити властивість буде неуспішною через configurable: false
delete obj.prop;

console.log(obj.prop); // 42 (не видалилося)

// Такі операції дозволяють вам контролювати поведінку властивостей об'єкта та визначати, як їх можна змінювати.

// ****** 35 / Чим відрізняється функція конструктор та клас у JS?


// У JavaScript терміни "клас" і "конструктор" також використовуються в контексті об'єктно-орієнтованого програмування, 
// але мають трошки відмінність в порівнянні з іншими мовами, такими як Python чи Jav

// Клас в JavaScript:

// У JavaScript введено ключове слово class для визначення класів.Синтаксис класів більш схожий на той, який використовується в інших мовах програмування,
// таких як Java чи C++. Клас може містити конструктор та інші методи.
// Наприклад:

class Car1 {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
    }

    drive() {
        console.log('Vroom!');
    }
}

const myCar2 = new Car1('Toyota', 'Camry');
myCar2.drive();


// Конструктор в JavaScript:

// Конструктор у JavaScript - це спеціальний метод з іменем constructor, який викликається при створенні нового об'єкта класу.
// Основна функція конструктора полягає в ініціалізації атрибутів об'єкта.
// Наприклад:

class Car2 {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
    }
}

const myCar3 = new Car2('Toyota', 'Camry');

console.log(myCar3);

// Отже, у JavaScript терміни "клас" і "конструктор" використовуються в контексті визначення об'єктів і встановлення їх властивостей,
// проте тут існує специфічний синтаксис для визначення класів, і конструктор може бути частиною цього класу.


// ************** 38. Що таке Promise?

// Promise(обіцянка) в JavaScript є об'єктом, який представляє результат асинхронної операції.
// Використовується для обробки асинхронного коду більш зручно та ефективно.

// Основні характеристики Promise:

// Стан (State):

// Promise може знаходитися у трьох станах: "в очікуванні" (pending), "виконано" (fulfilled) або "відхилено" (rejected).
// В стані "в очікуванні" він чекає завершення асинхронної операції.
// В стані "виконано" або "відхилено" об'єкт має результат або помилку.

// Обробка результатів:

// За допомогою методів .then() та .catch() можна обробляти результати асинхронних операцій.
// Метод .then() викликається, коли Promise виконується успішно.
// Метод .catch() викликається, коли Promise відхилено (з'явилася помилка).
// Л
// анцюг Promises:

// Можна ланцюгати кілька Promise разом, використовуючи .then(). Це називається "ланцюгом Promises" і дозволяє послідовно виконувати асинхронні операції.

// Приклад використання Promise:


function fetchDataFromServer() {
    // Логіка отримання даних
    // return someData;
}

const myPromise = new Promise((resolve, reject) => {
    // Асинхронна операція, наприклад, отримання даних з сервера
    const data = fetchDataFromServer();

    if (data) {
        resolve(data); // Promise виконується успішно
    } else {
        reject('Помилка 404 отримання даних'); // Promise відхилено
    }
});

myPromise
    .then(result => {
        console.log('Успішно отримано дані:', result);
    })
    .catch(error => {
        console.error('Помилка:', error);
    });
// У цьому прикладі myPromise є об'єктом Promise, який виконує асинхронну операцію отримання даних.
// Потім використовуються методи.then() та.catch() для обробки результатів або помилок.

// Об'єкт Promise в JavaScript є механізмом для взаємодії з асинхронним кодом і представляє собою операцію, 
// яка може бути завершена або успішно(виконана) або з помилкою(відхилена).
// Коли ви створюєте новий об'єкт Promise, ви передаєте функцію обратного виклику (executor function), 
// яка приймає два параметри: resolve та reject.Ці параметри є функціями, які ви викликаєте в залежності від того,
// чи вдалася асинхронна операція чи виникла помилка.

// resolve:

// resolve - це функція, яку ви викликаєте, коли асинхронна операція успішно завершується. Вона приймає один параметр - результат виконання операції.
// Коли ви викликаєте resolve, об'єкт Promise переходить в стан "виконано" (fulfilled), і будь-які прикріплені методи .then() викликаються з переданим результатом.

// reject:

// reject - це функція, яку ви викликаєте, коли асинхронна операція завершується з помилкою. Вона приймає один параметр - об'єкт або значення, що представляє помилку.
// Коли ви викликаєте reject, об'єкт Promise переходить в стан "відхилено" (rejected), і будь-які прикріплені методи .catch() викликаються з переданою помилкою.
// Приклад використання Promise з resolve та reject:



const myPromise1 = new Promise((resolve, reject) => {
    // Симуляція асинхронної операції
    const success = true;

    if (success) {
        // Викликаємо resolve, оскільки операція успішна
        resolve('Успішний результат');
    } else {
        // Викликаємо reject, оскільки виникла помилка
        reject('Помилка: операція не вдалася');
    }
});

myPromise1
    .then(result => {
        console.log('Успішно отримано дані:', result);
    })
    .catch(error => {
        console.error('Помилка:', error);
    });

// У цьому прикладі resolve та reject викликаються в залежності від умови success.
// Це дозволяє здійснювати обробку результатів або помилок, які можуть виникнути під час виконання асинхронної операції.

// ***********39.Для чого потрібен метод Promise.all?

// Метод Promise.all в JavaScript використовується для того, щоб обробляти асинхронний код,
//   коли потрібно чекати завершення кількох обіцянок(Promises) і отримати їхні результати.

// Основна ідея полягає в тому, що Promise.all очікує, доки всі передані йому об'єкти Promise будуть виконані,
// і повертає новий Promise, який виконується зі списком результатів в тому самому порядку, в якому передані об'єкти Promise.

// Синтаксис виглядає наступним чином:

// ==============
// Promise.all([promise1, promise2, promise3,])
//     .then(results => {
//         // results - це масив результатів відповідних об'єктів Promise
//         console.log(results);
//     })
//     .catch(error => {
//         // Обробка будь-якої помилки, яка виникне в одній з об'єктів Promise
//         console.error(error);
//     });
// =================
// Основні використання методу Promise.all:

// Запуск паралельних асинхронних операцій:

// Коли потрібно виконати кілька асинхронних операцій паралельно і дочекатися завершення всіх, щоб перейти до наступного етапу.
// Чекання на завершення всіх запитів:

// Коли, наприклад, у вас є кілька HTTP-запитів, і ви хочете дочекатися завершення всіх перед тим, як продовжити обробку даних.
// Запуск сумісних обчислень:

// Коли вам потрібно виконати декілька обчислень асинхронно і потім обробити результат, коли всі вони завершились.
// Примітка: Якщо хоча б одна обіцянка відхилено (rejected), то Promise.all теж буде відхилений, і його обробник помилок (catch) викличеться.


// **********************40. Для чого потрібен метод Promise.race?


// Метод Promise.race в JavaScript використовується для того, щоб обробляти асинхронний код,
//   коли потрібно чекати завершення першої обіцянки(Promise) зі списку, який передається методу.
//   Як тільки одна з переданих обіцянок виконається(буде виконана або відхилена), результат чи помилка буде використана для виклику обробника.then() чи.catch().

// Синтаксис виглядає наступним чином:

// =================================

// Promise.race([promise1, promise2, promise3,])
//     .then(result => {
//         // result - результат першої виконаної обіцянки
//         console.log(result);
//     })
//     .catch(error => {
//         // Обробка помилки першої відхиленої обіцянки
//         console.error(error);
//     });

// =================================

// Основні використання методу Promise.race:

// Запуск конкурентних асинхронних операцій:

// Коли вам потрібно отримати результат першої завершеної асинхронної операції зі списку, а інші можуть продовжувати виконуватися паралельно.
// Таймаут для операцій:

// Коли ви хочете обмежити час виконання операції та отримати результат, який призводиться до першої обіцянки, яка завершиться, навіть якщо інші обіцянки ще не завершилися.
// Перегони між запитами:

// Коли ви маєте кілька запитів або операцій і хочете отримати результат першої відповіді чи завершеної операції.
//   Примітка: Якщо перша обіцянка завершується успішно, то метод Promise.race викликає обробник.then().
// Якщо перша обіцянка завершується з помилкою(відхиленою), викликається обробник.catch().


// ******************  41.  Для чого потрібна async/await функція?

// async / await - це синтаксичний цукор в JavaScript, який дозволяє робити асинхронний код більш зрозумілим
//  і зручним для написання та читання.Основні цілі async / await включають:

// Спрощення асинхронного коду:

// Замість вкладених зворотних викликів(callbacks) чи використання об'єктів Promise, async/await дозволяє писати асинхронний код так, 
// як будто він синхронний.Це робить код більш зрозумілим для розробників.
// Зменшення вкладеності коду:

// Замість глибокого вкладення зворотних викликів чи ланцюгів Promise,
//   async / await дозволяє виразити послідовність асинхронних операцій в більш лінійному стилі,
//   що полегшує читання та розуміння коду.
    
// Керування винятками:

// За допомогою try/catch, обробка помилок в async/await стає більш природною. 
// Ви можете використовувати звичайний синтаксис обробки винятків для ловлення помилок в асинхронному коді.
// Покращення роботи зі зворотними значеннями:

// await очікує завершення асинхронної операції та повертає її результат. Це полегшує отримання значень і їх подальше використання.

// Приклад використання async / await:

// ===================================================
// async function fetchData() {
//     try {
//         const result1 = await fetchDataFromServer1();
//         console.log('Отримано дані 1:', result1);

//         const result2 = await fetchDataFromServer2();
//         console.log('Отримано дані 2:', result2);

//         // Додаткові асинхронні операції...

//         return 'Всі дані отримані успішно';
//     } catch (error) {
//         console.error('Виникла помилка:', error);
//         throw error; // Перенаправлення помилки вище
//     }
// }

// // Виклик функції fetchData
// fetchData()
//     .then(result => {
//         console.log('Результат:', result);
//     })
//     .catch(error => {
//         console.error('Помилка на верхньому рівні:', error);
//     });

// ==============================================================
// У цьому прикладі async / await дозволяє чекати результати асинхронних операцій за допомогою await.
//  При цьому обробка помилок виконується за допомогою конструкції try/catch, що робить код більш зрозумілим та керованим.









